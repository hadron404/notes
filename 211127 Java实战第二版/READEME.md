名：Java实战（第2版）
作者：（英）拉乌尔-加布里埃尔·乌尔玛（Raoul-Gabriel Urma），（意）马里奥·富斯科（Mario Fusco），（英）艾伦·米克罗夫特（Alan Mycroft）
译者：陆明刚　劳佳
出版社：人民邮电出版社
出版日期：2019-11-01
ISBN：9787115521484





## 第三部分 探索Java8和Java9的多个主题，介绍高级编程思想

8. 较上一版新增，探讨Java8和Java9对Collection API的增强
   * 如何使用集合工厂
   * 如何使用新的惯用模式处理List和Set
   * 如何通过惯用模式处理Map



小结

* Java9支持集合工厂，使用List.of()、Set.of()、Map.of()以及Map.ofEntries可以创建**小型不可变**的List、Set和Map
* 集合工厂返沪ide对象都是不可变的，这意味着创建之后不能修改它们的状态
* List接口支持默认方法removeiIf、replaceAll和sort
* Set接口支持默认方法removeIf
* Map接口为常见模式提供了几种新的默认方法，并降低了出现缺陷的概率
* ConcurrentHashMap支持从Map中集成的新默认方法，并提供了线程安全的实现

10. **⭐`较上一版新增，基于Lambda的领域特定语言`**
   - 介绍依据领域特定语言（domain-specific language DSL）来实现API的思想，比如Comparator、Stream以及Collector接口均采用这种模式实现
   - 领域特定语言及其形式
   - 除了简单的基于Java的DSL之外，JVM还有哪些领域特定语言可供选择
   - 从现代Java接口和类中学习领域特定语言
   - 高效实现基于Java的DSL都有哪些模式和技巧
   - 常见Java库以及工具式如何使用这些模式的

小结

* 引入DSL的主要目的是为了弥补程序员与领域专家之间对程序认知理解上的差异
* DSL的两大主要分类分别是内部DSL（采用与开发应用相同的语言开发的DSL）和外部DSL（采用与开发应用不同的语言开发的DSL）
* 可以利用JVM上已经存在的林一种语言开发多语言DSL，譬如Scala或者Groovy
* 由于自身冗长、烦琐以及僵硬的语法，Java并非创建内部DSL的例项语言，然而随着Lambda表达式及方法引用在Java8中的引入，这种情况有所好转
* 现代Java语言已经以原生API的方式提供了很多小型DSL
* 在Java中实现DSL有三种主要模式，分别是方法链接、嵌套函数以及函数序列
* 很多Java框架和库都可以通过DSL使用器特性
  * JOOQ：一种SQL映射工具
  * Cucumber：一种基于行为驱动的开发框架
  * Spring Integration：一种实现企业集成模式的Spring扩展库

## 第四部分 介绍Java8和Java9中新增的多个特性

14. 较上一版新增，探讨Java的模块系统——Java9的主要改进，使大型系统能够以文档化和可执行的方式进行模块化
    * 推进Java模块化之路的动力
    * 模块的主体结构：模块声明以及requires和exports指令
    * 针对Java对归档文件（JAR）的自动模块
    * 模块化以及JDK库
    * 使用Maven构建多个模块
    * 概述requires和exports之外的模块指令

小结

* 关注点隔离和信息隐藏是构造结构良好、易于维护与理解的软件的重要原则
* Java9之前，你可以根据特定的需求，利用包、类以及接口对代码进行模块化，不过以上这些方式都缺乏足够的特性，无法进行有效的封装
* “类路径地狱”问题导致我们很难对应用的依赖性进行分析
* Java9之前，JDK还是但体型的结构，导致很高的维护成本并限制了Java的演进
* Java9引入了新的模块系统，它通过module-info.java文件命名模块，指定其依赖性（通过requires）以及导出的公共API（通过exports）
* 使用requires子句，你可以指定一个模块对其他模块的依赖
* 使用exports子句可以导出模块中的某些包，将其声明为共有类型，提供给其他模块使用
* 推荐使用互联网域名的逆序作为模块的命名方式
* 位于模块路径上且没有提供module-info文件的JAR文件会被Java9作为自动模块处理
* 自动模块隐式地导出其全部包给其他模块使用
* Mava支持按照Java9模块系统构建的应用

第五部分 探讨如何使用Java的高级特性构建并发程序

15. 较上一版新增，从宏观的角度介绍异步API的思想，包括Future、反应式编程背后的“发布-订阅”协议（封装在Java9的Flow API）
    * 线程、Future以及推动Java支持更丰富的并发API的进化动力
    * 异步API
    * 从“线框与管道”的角度看并发计算
    * 使用CompletableFuture结合器动态地连接线框
    * 构成Java9反应式编程Flow API基础地“发布-订阅”协议
    * 反应式编程和反应式系统

小结

* Java对并发的支持由来已久，并且还在持续演进。通产而言，线程池技术很有帮助，然而如果你有大量可能阻塞的任务，使用它反而会带来麻烦
* 方法异步化（在完成它们的工作之前返回）能替身程序的并发度，其可以与用于循环结构的优化进行互补
* 使用线框-管道模型可以对异步系统进行可视化
* Java8的CompletableFuture类和Java9的Flow API 都可以通过线框-管道图表示
* CompletableFuture类常用于一次性的异步计算。使用结合器可以组合多个异步计算，并且无须担心使用Future时的阻塞风险
* Flow API基于“发布-订阅”协议，它与背压一起构成了Java 反应式编程的基础
* 反应式编程可以帮助实现反应式系统



17. ⭐**`较上一版新增，详细介绍Java9的Flow API，提供反应式编程的实战代码解析`**

* 什么是反应式编程以及[反应式宣言](https://www.reactivemanifesto.org/zh-CN)的原则
* 应用级和系统级的反应式编程
* 采用反应式流（reactive stream）以及Java9 Flow API实现的一个例子
* 一种广泛采用的反应式库——RxJava
* 如何使用RxJava转换和整合多个反应式流
* 如何使用弹珠图可视化地记录反应式流上的操作

小结

* 反应式编程背后的基本思想已经有二三十年的历史了，不过由于现代应用处理大量数据的需求以及用户预期的改变，它又再次出现在聚光灯下，变得炙手可热
* 反应式编程思想的正式提出是在反应式宣言中，它指出反应式软件必须具备四个相互关联的特性
  * 响应性
  * 韧性
  * 弹性
  * 消息驱动
* 反应式百年城原则通过微调，既可以用于构建单一应用，也可以用于设计反应式系统，整合多个应用
* 反应式应用基于反应式流承载的一个或多个事件流的异步处理。由于反应式流在开发反应式应用中的角色如此重要，Neftflix、Pivotal、Lightbend以及Red Hat等多家公司成立了联盟，致力于推动反应式概念的标准化，试图打破不同反应式库之间的互操作性障碍
* 由于反应式流异步处理的天然特征，它们往往都自带背压机制。背压(BackPresure)可以避免处理速度慢的消费方被高速的消息生产方压垮
* 反应式设计及其标准流程已经正式引入了Java。Java 9的Flow API定义了四个核心接口：Publisher、Subscriber、Subscription以及Processor
* 大多数情况下，这些接口不需要开发者直接去实现，它们主要作为实现反应式语义的第三方库的通用接口
* 应用最广泛的反应式库是RxJava，它（除了Java 9 Flow API中定义的那些基本特性之外）额外提供了很多便利而强大的操作。譬如，使用它提供的操作，你可以很便利地对单一反应式流中的元素进行转换和过滤，还可以整合和聚集多个流

