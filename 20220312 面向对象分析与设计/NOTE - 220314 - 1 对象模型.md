# 对象模型

## 开发对象模型（对象模型）

面向对象技术的要素 统称为 开发对象模型 或 简称为 对象模型

对象模型的原则

* 抽象
* 封装
* 模块化
* 层次结构
* 类型
* 并发
* 持久化

> 毫无疑问，面向对象分析和设计在本质上与传统的结构化设计方法是不同的：它要求一种不同的方式来思考分解，它得到的软件架构基本上超出了结构化设计的领域



### 2.1 对象模型的演进

> 面向对象开发不是从无数使用早期技术和失败的软件项目的灰烬中自发产生的。
>
> 它不是与早期方法断然决裂的
>
> 实际上，它建立在以前技术的最佳思想之上。

### 2.1.1 程序设计语言的换代

第一代语言（1954-1958  数学表达式） 主要用于科学和工程应用。这个问题领域的词汇几乎全是数学

第二代语言（1959-1961）重点是算法抽象

第三代语言（1962-1970）演进到支持数据抽象。程序员可以描述相关数据的意义（它们的类型），并让程序设计语言强制确保这些设计决策

代沟（1970-1980）

面向对象兴盛（1980-1990）基于对象和面向对象的程序设计语言，为软件的面向对象分解提供了最好的支持

框架的出现（1990-现在）程序设计框架通过提供组件和服务，简化了常见的、琐碎的变成任务，为程序员提供了很大的支持，极大地提高了生产效率



### 2.1.2 第一代和第二代早期程序设计语言的拓扑结构

拓扑结构（topology）指的是 这种语言的基本物理构成单元，以及这些部分是如何连接的

![](C:\Users\Administrator\Desktop\20220312 面向对象分析与设计\第一代和第二代程序设计语言的拓扑结构.png)

#### 缺点

* 全局数据结构对于所有子程序都是可见的。程序种某个部分的错误可能给系统的其他部分带来毁灭性的连带影响
* 在对大型系统进行修改时，很难维持原有设计的完整性，并且常常会引入混乱
  * 包含子程序间的大量交叉耦合
  * 对数据含义的假定及复杂的控制流，威胁整个系统的可靠性
* 降低解决方案的整体清晰性



### 2.1.3 第二代后期和第三代早期程序设计语言的结构



意识到子程序可以作为一种抽象机制，这产生了三个重要结果

* 发明一些语言，支持各种参数传递机制
* 奠定了结构化程序设计的基础
* 出现了结构化设计方法，为试图构建大型系统的设计提供了指导，利用子程序作为基本构建块

缺点

* 仍然未能解决大规模程序设计和数据设计的问题



### 2.1.4 第三代后期程序设计语言的结构

演进方向

* 支持模块化

缺点

* 缺乏对模块间接口的语义一致性
* 对数据抽象和强类型的支持都不太好，只有在执行程序时才能被检测出来



### 2.1.5 基于对象和面向对象的程序设计语言的结构

> 在许多应用中，要操作的数据对象的复杂性在很大程度上决定了问题的复杂性

* 数据驱动的方法
* 关于类型概念的理论



## 2.2 对象模型基础

> 结构化的设计方法指导开发者利用算法作为基本构建块来构建复杂系统
>
> 面向对象设计方法利用类和对象作为基本构建块，指导开发者探索基于对象和面向对象编程语言的表现力

### 什么是面向对象，什么是不能面向对象？

基本概念：对象统一了算法抽象和数据抽象的思想

>在对象模型中，重点在于灵活地刻画物理系统或抽象系统的组件，用一个程序系统来建模....对象具有某种‘完整性’，这种完整性不应违反，实际上也不能违反
>
>对象只能按照它的方式来改变状态、改变行为、实现操作或与其他对象发生联系

#### 基础-对象模型

对象代表了按模块分解的系统的组件，或者是知识表达的模块化单元

##### 下列事件促使了面向对象概念的演进

* 计算机架构的进步，包括基于功能的系统以及对操作系统概念的硬件支持
* 程序设计语言的进步，如Simula、Smalltalk、CLU和Ada
* 编程方法学的进步，包括模块化和信息隐藏
* 数据库模型的进步
* 对人工智能的研究
* 哲学和认知科学领域的进步

> 17世纪，笛卡尔说人们很自然地用面向对象地观点来看世界
>
> Rand在她的客观主义认知论哲学中对这些主题进行了扩展
>
> Minsky提出了一个人类智能的模型，在这个模型中，他认为意识是由一些无意识的代理构成群体。只有通过这些代理的协作，我们才能发现所谓的”智能“



### 2.2.1 面向对象编程（OOP）

#### 什么是OOP？

> 面向对象编程是一种实现的方法，在这种方法中，程序被组织成许多组相互协作的对象，每个对象代表某个类的一个实例，而类则属于一个通过继承关系形成的层次结构

* 利用对象作为面向对象编程的基本逻辑构建块，而不是利用算法（“part of”的层次结构）
* 每个对象都是某个类的一个实例
* 类与类之间可以通过继承关系联系在一起（“is a”的层次结构）

一个程序可能看起来像是面向对象的，但是如果不满足这三点之一，他就不是一个面向对象的程序。具体来说，没有继承的编程显然不是面向对象的，那只是利用抽象数据类型在编程

> Stroustrup建议，如果面向对象语言这个术语有意义的话，它一定是意味着一种语言具有一些机制，能很好地支持面向对象风格地编程....
>
> 如果语言提供的机制能够使得利用一种风格编程很方便，那么这种语言就很好地支持了这种风格
>
> 如果使用一种语言需要额外地努力或技能才能编写这样的程序，那它就不支持这种技术



当且仅当一种语言满足谢列需求时，它才是面向对象的

* 它支持对象，这些对象是具有命名的操作接口和隐藏的内部状态的数据愁绪爱过你
* 对象具有相关的类型[类]
* 类型[类]可以从超类型[超类]中继承属性

> 一种语言不提供对继承的直接支持，那么它就不是面向对象的，Cardelli和Wegner将这种语言称为“基于对象（object-based）”的，而不是面向对象（object-oriented)的
>
> 因为对象和类是这两种语言的基本元素，所以在基于对象和面向对象的语言中，都可以使用面向对象设计，而且也是非常推荐的





### 2.2.2 面向对象编程

#### 什么是OOD？

> 面向对象设计是一种设计方法，包括面向对象分解的过程和一种表示法，这种表示法用于展现被设计系统的逻辑模型和物理模型、静态模型和动态模型

* 面向对象设计导致了面向对象分解
* 面向对象设计使用了不同的表示法，来表达系统逻辑设计（类和对象结构）和物理设计（模块和处理架构）的不同模型，以及系统的静态和动态特征



### 2.2.3 面向对象分析

> 面向对象分析是一种分析方法，这种方法利用从问题域的词汇表中找到的类和对象来分析需求

OOA、OOD和OOP之间的关系如何？

> 基本上，面向对象分析的结果可以作为开始面向对象设计的模型，面向对象设计的结果可以作为蓝图，利用面向对象编程方法最终实现一个系统





## 2.3 对象模型要素

5种主要的编程风格及它们使用的抽象

* 面向过程 算法
* 面向对象 类和对象
* 面向逻辑 目标，通常以谓词演算的方式标识
* 面向规则 如果-那么规则
* 面向约束 不变的关系



对象模型的四个主要要素

* 抽象
* 封装
* 模块化
* 层次结构

> “主要”，如果一个模型不具备这些元素之一，就不是面向对象的



对象模型的三个次要要素

* 类型
* 并发
* 持久

> “次要”，这些要素是对象模型的有用组成部分，但那不是本质的



### 2.3.1 抽象的意义

抽象是我们人类处理复杂性的基本方式

> Shaw：
>
> 对一个系统的一种简单的描述或指称，强调系统的某些细节或属性同时抑制另一些细节或属性
>
> 好的抽象强调了对读者或用户重要的细节，抑制了那些至少是暂时的非本质细节或枝节
>
> 
>
> Berzions、Gray和Naumann建议：
>
> 只有当一个概念可以独立于最终使用和实现它的机制来描述、理解和分析时，我们才说这个概念是抽象的。
>
> 
>
> 结合不同的观点，给出定义：
>
> 抽象描述了一个对象的基本特征，可以将这个对象与所有其他类型的对象区分开来，因此提供了清晰定义的概念边界，它与观察者的视角有关



从那些准确地为问题域实体建模的对象到那些实际上没有什么理由存在的对下个你，存在着一系列的抽象。按最有用到最没有用的次序如下

* 实体抽象：一个对象，代表了问题域或解决方案域实体的一个有用的模型
* 动作抽象：一个对象，提供了一组通用的操作，所有这些操作都执行同类的功能
* 虚拟机抽象：一个对象，集中了某种高层控制要用到的所有操作，或者这些操作将利用某种更低层的操作集
* 偶然抽象：一个对象，封装了一组相互间没有关系的操作



### 2.3.2 封装的意义

#### 意义

对象的抽象应该优先于它的实现决定。当选择了一种实现之后，它就应该作为这种抽象后面的秘密，对绝大多数客户隐藏

> 抽象和封装是互补的概念：抽象关注的是对象可以观察到的行为，而封装关注这种行为的实现。

抽象帮助人们思考他们做什么，而封装“让程序可以借助最少的工作进行可靠的修改”

> 封装在不同的抽象之间提供了明确的边界，因此导致了清晰的关注点分离

#### 定义

封装是一个过程，它分隔构成抽象的结构和行为的元素。封装的作用是分离抽象的概念接口及其实现

Britton和Parnas将这些被封装的元素称为抽象的秘密



### 2.3.3 模块化的意义

* 管理复杂性
* 易理解
* 设计灵活性

模块化将程序划分为一些模块，这些模块可以独立地编译，但又与其他模块有联系。

> Parnas定义：模块之间的联系是模块相互之间所做出的假定

大多数语言将模块作为一个独立的概念，它们也区分模块的接口和它的实现。因此，可以说模块化和封装是密不可分的。

> 从高内聚、低耦合角度定义
>
> 模块化是一个系统的属性，这个系统被分解为一组高内聚、低耦合的模块



帮助实现对类和对象的明智的模块化的技术上和非技术上的指导方针

* 分解为模块的总体目标是通过允许模块独立地设计和修改，从而减少软件的成本
* 每个模块的结构足够简单，以至于能被完全理解
* 能够在不知道其他模块的实现方法，并不会影响其他模块的行为的情况下，修改某个模块的实现
* 修改设计的容易程度应该能够满足需要变更的可能性
* 努力创造出高内聚（将逻辑上相关的抽象放在一起）、低耦合（减少模块间的依赖关系）的模块

两种竞争

* 模块的接口应该尽可能小
* 接口同时需要满足其他用到它的模块的需要

平衡两种竞争的技术考虑

1. 封装抽象的愿望以及让其他模块看到某些抽象的需要
2. 模块通常是软件的基本可分割单元，可以跨应用复用，开发者可能以方便复用的方式对类和对象进行打包
3. 许多编译器以分段的方式产生目标代码，每个模块生成一段，因此，对单个模块的规模可能有实际的限制
4. 开发团队通常根据模块来分配工作的，所以建立模块边界时要尽量减少开发组织中不同部分之间的接口



> 发现正确的类和对象，然后将它们放到不同的模块中，这基本上是独立的设计决定
>
> 类和对象的确定是系统逻辑设计的一部分，而模块的确定是系统物理设计的一部分
>
> 我们不能在物理设计之前完成所有逻辑设计，反之亦然

设计决策是一种迭代的方式进行的

### 2.3.4 层次结构的意义

层次结构是抽象的一种分级或排序

复杂系统中，最重要的两种层次结构

* 类结构（”is a”层次结构）
  * 单继承（最重要的一种“is a”层次结构）
* 对象结构（“part of”层次结构）



继承

* 是面向对象系统的基本要素
* 基本上定义了类之间的关系，
* 代表了一种抽象的层次结构。一般来说，子类会扩展或重新定义超类中的结构和行为
* 从语义上说，继承表明了“是一种”的关系，因此实现了一种“一般/具体”的层次结构，其中子类将超类的一般结构和行为具体化
  * 继承的判据：如果B不是一种A，那么B就不应该从A继承
  * 一般/具体层次结构
    * 超类代表了一般化的抽象，子类代表了特殊的抽象
    * 继承称为“一般/具体”的原因：不同类中共同的结构和行为会被迁移到共同的超类中
  * 继承的判别测试：如果B不是一种A，那么B就不应该从A继承



多继承

多继承对于这种既是什么，又是什么的抽象在概念上是更好的表达方式

多继承会导致的问题

* 来自不同超类的名字的冲突
* 重复继承



聚合

* “part of” 层次结构则描述了聚合关系
* 聚合不是面向对象开发或面向对象编程语言所特有的概念
* 聚合允许对逻辑结构进行物理分组，而继承允许这些共同的部分在不同的抽象中被复用
* 聚合提出了所有权的问题



抽象的层次

对于“is a”层次结构，高层的抽象是一般的，底层的抽象是具体的。

对于“part of”层次结构，一个类相对于组成它的实现的类来说，处于更高的层次。因此，种植园是植物类的更高层抽象

### 2.3.5 类型的意义

> 类型的概念主要来自于抽象数据类型的理论
>
> “一个类型是关于结构或行为属性的准确描述，一组实体共享这些属性”
>
> 类型是关于一个对象的类的强制规定，这样依赖，不同类型的对象不能够互换使用，或者至少它们的互换使用受到非常严格的限制

* 某种编程语言可以是强类型、弱类型甚至无类型的，但都可以被称为是面向对象的
* 类型匹配的概念是类型概念的核心

两个问题

* 不同类型的对象被错误地混用
* 不知道当前处理的是哪一种对象

强类型

* 防止将抽象弄混
* 可以利用编程语言来强制保证某些设计决策
* 从实践上看，引入了语义上的依赖关系（即使是基类接口的一个小改动，也需要重新编译所有的子类）

不使用强类型如何解决以上两个问题

1. 使用类型安全的容器类。它只操作某一个类的对象————解决了 不同类型的对象被错误地混用
2. 使用某种运行时刻地类型标识 ———— 解决了 知道当前处理的是哪一种类型的对象（谨慎使用，会削弱封装）
   1. 通常使用 多态 可以缓解运行时类型标识的需要

使用强类型的语言有一些重要的好处

* 如果没有类型检查，大部分语言的程序可能在运行时以神秘的方式“崩溃”
* 在大多数系统中，编辑-编译-调试循环相当烦琐，所以早期的错误检查是必不可少的
* 类型声明有助于为程序编写文档
* 如果声明类型，大部分编译器可以生成更有效率的目标代码

> 类型的强与弱指的是类型一致性，而类型的静态与动态指的是名字与类型绑定的事件



多态

* 是动态类型和继承相互作用时出现的一种情况
* 代表了类型理论中一个概念，即一个名字可以代表不同类的对象，这些类具有某个共同的超类，这个名字所代表的对象因此可以响应一组共同的操作
* 多态可能是面向对象语言中除了对抽象的支持以外最强大的功能
* 多态区分了面向对象编程和较传统的抽象数据类型编程
* 是面向对象设计中的核心概念

### 2.3.6 并发的意义

并发允许不同的对象同时行动

并发的种类

* 重量级并发
* 轻量级并发

在最高层次的抽象中，通过将并发隐藏在可复用的抽象中，OOP可以减轻大多数程序员在并发问题上的负担

> “对象模型适合于分布式系统，因为隐式地定义了发布和移动的单元以及实体的通信”

主动对象

每个对象（来自于真实世界的一个抽象）都可以代表一个独立的控制线程（一种过程抽象）

> 并发的定义
>
> 并发是一种属性，它区分了主动对象和非主动对象



面向对象设计中的并发方式

1. 并发是某种编程语言的内在特征，语言提供了并发和同步的机制
2. 使用一个类库来实现某种形式的轻量级进程
3. 可以利用中断来实现并发的假象

> 不论采用哪种方法实现并发，都必须注意这样一个事实：当在一个系统中引入并发时，必须考虑主动对象之间、主动对象与纯粹串行执行的对象之间，如何同步它们的活动

### 2.3.7 持久的意义

> 持久时对象的一种属性，利用这种属性，对象跨越时间（例如，当对象的创建者不存在了的时候，对象仍然存在）和空间（例如，对象的位置从它被创建的地址空间移开）而存在

对象持久的谱系

* 表达式计算的瞬时结果
* 过程执行时的局部变量
* 自有变量、全局变量、堆中的值，它们的存在时间与它们的有效范围不同
* 在程序执行之间存在的数据
* 在程序的不同版本之间存在的数据
* 比程序生命期长的数据



## 2.4 应用对象模型



应用对象模型可以带来的好处

* 使用对象模型构建的系统博鳌韩良好构造的复杂系统的5个属性
  * 层次结构
  * 相对的基础
  * 关注点分离
  * 模式
  * 稳定的中间状态
* 使用对象模型帮助我们探索基于对象和面向对象编程语言的表达能力  ———— 面向对象设计
* 利用对象模型不仅鼓励软件的复用，而且鼓励整个设计的复用，这导致了可复用应用框架的产生
* 使用对象模型将得到构建在稳定的中间状态之上的系统，这样的系统更适合变化
* 对象模型减少开发复杂系统所固有的风险
* 对象模型引起了对人类认知工作的兴趣

> “许多不知道计算机如何工作的人会发现，面向对象系统的思想非常自然”



开放式问题

* 究竟什么是类和对象
* 如何正确地确定与特定应用有关的类和对象
* 怎样的表示法适合表示面向对象系统的设计
* 怎样的过程可以导致结构良好的面向对象系统
* 使用面向对象设计对管理层意味着什么