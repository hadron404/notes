# 类与对象

## 对象的本质

### 什么是对象

* 一个可以触摸或可以看见的东西
* 在智力上可以理解的东西
* 可以指导思考或行动的东西
* 是在时间和空间中存在的某种东西（一个对象反映了某一部分的真实存在）
* 拥有一些属性
* 所有的对象都有某种值
* 每个对象都有状态

> 一个对象代表了单个可识别的项、单元或实体，它可以是真实的，也可以是抽象的，在问题域中承担定义良好的角色

> 对象是一个具有状态、行为和标识符的实体。结构和行为类似的对象定义在它们共同的类中

每个对象都有状态。这一事实意味着，每个对象都会在物理世界或计算机内存中占据一定的空间

### 状态

> 对象的状态包括这个对象的所有属性（通常是静态的）以及每个属性当前的值（通常是动态的）
>
> 改进后的定义：
>
> 一个对象的状态代表了它的行为的累积效果

属性是一种内在或独特的特征、特点、品质或特性，使一个对象区别于别的对象

### 行为

> 行为是对象在状态改变和消息传递方面的动作和反应的方式

### 角色和职责

> 角色是一个对象戴上的一个面具，它定义了一种抽象与它的客户之间的契约
>
> 职责意味着表达对象的一种目标以及它在系统中的位置。一个对象的职责是它为支持的所有契约提供的全部服务

### 标识符

> 标识符是一个对象的属性，它区分这个对象与其他所有对象

### 对象之间的关系

* 链接
* 聚合

#### 链接

> 两个对象之间物理上或概念上的联系
>
> 链接表明了一种端到端的关系或客户/服务提供者的关系

作为链接的参与者，一个对象可能扮演以下三种角色之一

* 控制器：这个对象可以操作其他对象，但不会被其他对象操作。在某些地方，主动对象和控制器这两个术语是互换使用的
* 服务器：这个对象不操作其他对象，它只被其他对象操作
* 代理：这个对象既可以操作其他对象，也可以被其他对象操作。创建代理通常是为了表示问题域中的一个真实对象



当一个主动对象与一个被动对象之间有链接时，我们必须选择以下三种同步方式之一

* 顺序：只有在某一时刻只存在一个主动对象时，被动对象的语义才得到保证
* 守卫：在多个控制线程的程序下，被动对象的语义才能保证，但主动的客户之间必须协作，以实现互斥访问
* 并发：在多个控制线程的程序下，被动对象的语义也能保证，服务提供者保证互斥

#### 聚合

> 聚合表明了一种整体/部分层次结构，提供了从整体（也称为聚合体）导航到它的部分的能力
> 聚合可以代表物理上的包含，也可以不代表



## 类的本质

> 对象是存在于时间和空间中的具体实体，而类仅代表一种抽象，即一个对象的本质

### 什么是类

> 在面向对象分析和设计的上下文中，我们将类定义为
>
> 类是一组对象，它们拥有共同的结构、共同的行为和共同的语义

### 什么不是一个类

* 一个对象不是一个类
* 没有共同结构和行为的对象不能够被划分为一类

#### 组件

> 一种相当高层的抽象、一个GUI框架、一个数据库和整个库存系统在概念上都是独立的对象。
>
> 但它们都不能表示为一个单独的类
>
> 相反，最好是将这些抽象表示为一组类，这些类的实例互相协作，提供我们所期望的结构和功能，这样的一组类称为组件



### 接口和实现

> 编程在很大程度上是一种“制定契约”：一个较大问题的不同功能通过子契约被分配给不同的设计元素，从而被分解成较小的问题
>
> 类起到的作用是在一种抽象和所有它的客户之间建立起协议

使用契约的观点进行编程，可以区分一个类的外部视图和内部视图。

#### 类的接口

> 一个类的接口提供了它的外部视图，因此强调了抽象，隐藏了它的结构和行为的秘密

类接口可以分成以下四个部分

* 公有：所有客户都可以访问的声明
* 保护：只能由该类本身及其子类访问的声明
* 私有：只能由该类本身访问的声明
* 包：只能由同一个包中的类访问的声明

#### 类的实现

> 与接口不同，类的实现是它的内部视图，它包含类行为的秘密



## 类之间的关系

> 对于一个特定的问题域，一些关键的抽象通常与各种有趣的方式联系在一起，形成了我们设计的类结构
>
> 一种类关系可能表明某种类型的共享，其次，一种类关系可能表明某种语义上的联系

类关系的分类

* 一般/特殊关系，表示“is a”关系
* 整体/部分关系，表示“part of”关系
* 关联，表示某种语义上的依赖关系

#### 关联

> 确定类之间的关联通常是分析和早期设计的活动
>
> 关联只代表一种语义上的依赖关系

关联有以下三种常见的多重性

* 一对一
* 一对多
* 多对多

#### 继承

> 代表了一般/特殊的关系

##### 单继承

> 简单来说，继承是类之间的一种关系，在这种关系中，一个类共享了另一个类（单继承）或多个类（多继承）中定义的结构和行为。
>
> 提供给其他类继承的类称为：超类
>
> 子类通产扩展或限制了超类中原有的结构和行为。扩展超类的子类被称为扩展继承

##### 多态

> 多态是类型理论中的一个概念，即一个名字可能代表许多不同类的实例，只要它们都有共同的超类。
>
> 于是，由这个名字所代表的对象就能够以不同的方式对同一组操作做出反应

利用多态，一个操作可以被层次结构中的类以不同的方式实现

#### 聚合

> 提供了类实例中的整体/部分关系

* 物理包容：按值包容的聚合
  * 聚合类和被聚合类的生命周期是一致的
* 组合：按引用包容的聚合
  * 可以独立地创建和销毁每个类的实例

聚合的判别测试

> 当且仅当两个对象存在整体/部分关系时，它们对应的类之间必然存在一种聚合关系



#### 依赖关系

> 依赖关系表明，处于这种关系一端的元素以某种方式依赖于处于另一端的元素
>
> 警告了设计者，如果其中一个元素发生了改变，可能会影响到另一个元素。



## 类与对象的互动

分析阶段和设计的早期阶段，开发者有两项主要任务

* 从问题域的词汇表中确定出类
* 创建一些结构，让多组对象一起工作，提供满足问题需求的行为

> 这样的类和对象统称为问题的“关键抽象”，把这些协作结构称为实现的“机制”

设计阶段的后期以及随后的实现阶段

* 这些抽象和机制的内部视图
* 物理实现

## 创建高品质的类与对象

* 评判抽象的品质

* 选择操作

* 选择关系

* 选择实现

  

### 0 如何知道某个类或对象的设计是良好的？

通过以下5个测量指标

* 耦合：测量一个模块与另一个模块之间建立起的关联强度
* 内聚：测量单个模块内各个元素的联系程度
* 充分性：类或模块应该记录某个抽象足够多的特征，从而允许有意义的、有效的交互
* 完整性：类或模块的接口记录了某个抽象全部有意义的特征
* 基础性：只有访问该抽象的底层表现形式才能够有效地实现的那些操作

##### 如何选择类的基础性操作？

1. 一个操作只能通过访问底层表现形式来实现
2. 一个操作可以在已有的基础性操作之上实现，但会消耗大量的计算资源，也可以作为基础性操作的候选者



### 1 如何选择操作？

> 对于一个给定的类，我们的风格是让所有的操作保持基础性，这样每个操作都展示出小的、定义良好的行为，我们把这样的方法称为“细粒度的（fine-grained)”
>
> 我们也倾向于分离方法，让它们相互之间不通信，通过这种方式，我们更容易构造一些子类，它们可以有意义地重新定义超类的行为

1、 功能语义角度

* 让所有的操作保持基础性
* 分离方法，它们相互之间不通信

> 好的设计者知道如何在太多契约和太少契约之间平衡，太多契约导致片段化，太少契约导致无法管理的大模块
>
> 在面向对象开发中，通常会整体设计一个类的所有方法，因为这些方法共同构成了这个抽象的完整协议

##### 对于某个期望的行为，如何决定将它放到哪个类中?

* 可复用性：这个行为可以在多种上下文中使用吗
* 复杂性：实现这个行为的难度有多大
* 适用性：这个行为与打算放入的类型之间相关程度如何
* 实现知识：这个行为的实现依赖于一个类型的内部细节吗

2、 时间和空间语义

* 决定完成操作所需要的时间以及存储空间
* 在支持并发的语言中，必须关注更为复杂的消息传递形式



### 2 选择关系

选择对象间的关系，有一条有用的指导原则，称为Demeter原则

> Demeter原则
>
> 类的方法不应该以任何方式依赖于任何类的结构，除了它自己类的当前（顶层）结构之外。而且，每个方法只能够对一个非常有限的类集的对象发出消息



2、机制和可见性

决定对象之间的关系主要是设计这些对象进行交互的机制



