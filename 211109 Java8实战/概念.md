# 相关概念

## 第一部分 基础知识

### 一等值

> 或叫一等公民，从20世纪60年点美国民权运动中借用来的、

编程语言的整个目的就在于操作值，这些值因此被称为一等值

编程语言中的其他结构也许有助于我们表示值的结构，但在程序执行期间不能传递，因而是二等公民

Java中的值可以称为一等公民，其他的Java概念（比如方法和类等）则是二等公民



### 流处理

> 流式一系列数据项，一次只生成一项
>
> 程序可以从输入流中一个一个读取数据项，然后以同样的方式将数据项写入输出流
>
> 一个程序的输出流很可能是另一个程序的输入流

### Predicate(谓词)

> 在数学上常常用来代表一个类似函数的东西，它接受一个参数值，并返回true或false
>
> 谓词，用来代替或者展示其[客体](https://baike.baidu.com/item/%E5%AE%A2%E4%BD%93/9990629)性质、特征或者[客体](https://baike.baidu.com/item/%E5%AE%A2%E4%BD%93/9990629)之间关系的[词项](https://baike.baidu.com/item/%E8%AF%8D%E9%A1%B9/861117)。根据《现代汉语》的定义,汉语的[体词](https://baike.baidu.com/item/%E4%BD%93%E8%AF%8D/4928773)包括[名词](https://baike.baidu.com/item/%E5%90%8D%E8%AF%8D/502047),[数词](https://baike.baidu.com/item/%E6%95%B0%E8%AF%8D/1523081),[量词](https://baike.baidu.com/item/%E9%87%8F%E8%AF%8D/10830424)；汉语的谓词可以包括一切的例句



### 外部迭代

> 使用for-each循环一个个去迭代元素，然后在处理元素的数据迭代方法



### 内部迭代

> 不用操心循环，数据处理完全是在库内部进行的思想



### 行为参数化

> 让方法接受多种行为（或战略）作为参数，并在内部使用，来完成不同的行为

### Lambda表达式

> lambda表达式由参数、箭头和主体组成
>
> 可理解为 简洁地表示可传递地匿名函数地一种方式

* 匿名：没有类似普通方法有一个明确的名称：写得少而想得多
* 函数：Lambda函数不像普通方法属于某个特定的类，但和方法一样，有参数列表、函数主题，返回类型，还可能有抛出的异常列表
* 传递 Lambda表达式可以作为参数传递给方法或存储在变量中
* 简洁 无需像匿名类那样写很多模板代码

### 函数式接口

>  **函数式接口**就是只定义一个抽象方法的接口

比如

```java
public interface Predicate<T>{
    boolean test(T t);
}
```

#### 三个泛型函数式接口

* Predicate
* Consumer
* Function

#### 专门的函数式接口

* IntPredicate
* DoublePredicate
* IntConsumer
* LongBinaryOperator
* IntFunction
* ToIntFunction<T>
* IntToDoubleFunction

### 函数描述符

> 函数式接口的抽象方法的签名称为**函数描述符**

### 环绕执行模式

> 资源处理（例如处理文件或数据库）时一个常见的模式就是打开一个资源，做一些处理，然后关闭资源。这个设置和清理阶段总使很类似，并且会围绕着执行处理的那些重要代码。



### 装箱（boxing）

> 将原始类型转换为对应的引用类型的机制

### 拆箱(unboxing)

> 与装箱的相反操作。将引用类型转换为对应的原始类型



### 目标类型

> 上下文（比如接受它传递的方法的参数，或接受它的值的局部变量）中Lambda表达式需要的类型称为**目标类型**



### 自由变量

> 不是参数，而是在外层作用域中定义的变量



### 捕获Lambda

> Lambda表达式也允许使用自由变量，就像匿名类一样，它们被乘坐捕获Lambda

```java
int portNumber = 1337;
Runnable r = ()-> System.out.println(portNumber);
```



### 方法引用

> 如果一个Lambda代表的知识“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如何调用它。
>
> 方法引用可以被看作仅仅调用特定方法的Lambda的一种快捷方法



### 比较器

## 第二部分 函数式处理

### 集合

> 

### 流

> 从支持数据处理操作的源生成的元素序列

* **元素序列** 特定元素类型的一组有序值
* **源** 提供数据的地方比如集合、数组或输入/输出资源
* **数据处理操作** 类似数据库操作，比如filter、map、reduce、find、match、sort



### 声明性方式的代码

> 说明想要完成什么（筛选热量低的菜肴），而不是说明如何实现一个操作（利用循环和if条件等控制流语句）



### 高层次构件





### 中间操作

> 可以连接起来的流操作称为**中间操作**

### 终端操作

> 关闭流的操作称为**终端操作**



### filter（筛选）

### 切片

### limit（截短）

### skip（跳过）

### map（映射）

### flat Map（扁平化）

### 流的扁平化

> 将多个流映射成一个流

### Reduce（归约）



### 短路

> 不管布尔表达式有多长，只要其中一个表达式推断出结果就可以推断整个表达式的结果，不需要计算整个表达式，这就是短路
>
> 短路分为短路与、短路或
>
> and（&&） 、or（||）

### 循环合并技术

> 将两个独立的操作，合并到一次遍历的技术



### 无状态流操作

> 没有内部状态的流操作
>
> 比如 map、filter

### 有状态流操作

> 有内部状态的流操作
>
> 比如 distinct、sort



### 原始类型流特化

>Java 8引入了三个原始类型特化流接口来解决这个问题：IntStream、DoubleStream和LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本



### 无限流

> 没有固定大小的流



### Collection

### Collector

### collect

### 预定义收集器

> 可以从Collectors类提供的工厂方法创建的收集器

三大基本功能：

* 将流元素归约和汇总为一个值
* 元素分组
* 元素分区

### Collector接口

> Collector接口包含了一系列方法，为实现具体的归约操作（即收集器）提供了范本。

```java
public interface Collector<T, A, R> {
    Supplier<A> supplier();
    BiConsumer<A, T> accumulator();
    Function<A, R> finisher();
    BinaryOperator<A> combiner();
    Set<Characteristics> characteristics();
}
```

* `T` 是流中要收集的项目的泛型
* `A` 是累加器的类型，累加器是在收集过程中用于累计部分结果的对象
* `R` 是收集操作得到的对象（通常但不一定是集合）的类型

#### 1.supplier() 建立新的结果容器

#### 2.accumulator（） 将元素添加到结果容器

#### 3.finisher() 对结果容器应用最终转换

#### 4.combiner() 合并两个结果容器

#### 5.characteristics（）定义收集器的行为

* UNORDERED——归约结果不受流中项目的遍历和累积顺序的影响
* CONCURRENT——accumulator函数可以从多个线程同时调用，且该收集器可以并行归约流。如果收集器没有标为UNORDERED，那它仅在用于无序数据源时才可以并行归约
* IDENTITY_FINISH——这表明完成器方法返回的函数是一个恒等函数，可以跳过。这种情况下，累加器对象将会直接用作归约过程的最终结果。这也意味着，将累加器`A`不加检查地转换为结果`R`时安全的。



### `parallelStream` （并行流）

> 并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流



### fork/join框架（分支/合并框架）

> Java1.7新引入的并行数据处理框架
>
> fork/join框架的目的是以递归方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果
>
> 它是ExecutroService接口的一个实现，它把子任务分配给线程池（ForkJoinPool）中的工作线程

#### `RescuriveTask<R>`

> R 是并行化任务（以及所有子任务）产生的结果类型
>
> abstract compute()定义了将任务拆分成子任务的逻辑，以及无法再拆分或不方便再拆分时，生成单个子任务结果的逻辑



### work stealing （工作窃取）

#### 算法思想

实际应用中，这意味着这些任务差不多被平均分配到`ForkJoinPool`中的所有线程上。每个线程都为分配给它的任务保存一个双向链式队列，每完成一个任务，就会从队列头上取出下一个任务开始执行。基于前面所述的原因，某个线程可能早早完成了分配给它的所有任务，也就是它的队列已经空了，而其他的线程还很忙。这时，这个线程并没有闲下来，而是随机选了一个别的线程，从队列的尾巴上“偷走”一个任务。这个过程一直继续下去，直到所有的任务都执行完毕，所有的队列都清空。

> 一般来说，这种工作窃取算法用于在池中的工作线程之间重新分配和平衡任务

### Spliterator

> 一个自动拆分多个任务的机制
>
> Spliterator 是Java8中加入的另一个新接口，表示“可分迭代器”（splitable iterator）,为了并行执行而设计的

```java
public interface Spliterator<T> {
    boolean tryAdvance(Consumer<? super T> action);
    Spliterator<T> trySplit();
    long estimateSize();
    int characteristics();
}
```

* `T` 是`Spliterator`遍历的元素的类型
* `tryAdvance()`的行为类似于普通的`Iterator`，顺序遍历`Spliterator`中的元素，并且如果还有其他元素要遍历返回`true`
* `trySplit()`专为`Spliterator`接口设计的，将元素划出去分给第二个`Spliterator`（由该方法返回），让它们并行处理
* `estimateSize()` 估计剩下需要遍历的元素大小
* `characteristics()`

### late-binding(延迟绑定)

> 可以在第一次遍历、第一次拆分或第一次查询估计大小时绑定元素的数据源，而不是在创建时就绑定的情况就成为延迟绑定（late-binding）的Spliterator



### 默认方法

> 接口能提供方法的具体实现
>
> 默认方法的引入为了以兼容的方式解决像Java API 这样的类库的演进问题



### companion class (工具辅助类)

> 工具类定义了与接口实例写作的很多静态方法



### 不同类型的兼容性

* 二进制兼容性
* 源代码兼容性
* 函数行为兼容性

> 参见：https://blogs.oracle.com/darcy/entry/kinds_of_compatibility

#### 二进制兼容性

> 现有的二进制执行文件能无缝持续链接（包括验证、准备和解析）和运行

#### 源代码级的兼容性

> 源代码级的兼容性表示引入变化之后，现有的程序依然能成功编译通过

#### 函数行为的兼容性

> 函数行为的兼容性表示变更发生之后，程序接受同样的输入能得到同样的结果



### 可选方法



### 行为的多继承

> 让类从多个来源重用代码的能力



### Safe Navigation Operator 安全导航操作符

### 阻塞式调用

> 

### 非阻塞式调用



### 函数式编程

> 一种最简化的回答： 是一种使用函数进行编程的方式
>
> 具体实践了声明式编程和无副作用计算

### 纯粹的/无副作用的

> 一个方法既不修改它内嵌类的状态，也不修改其他对象的状态，使用return返回所有的计算结果，那么就可以称其为 **纯粹的**或者**无副作用的**



### 副作用

* 除了构造器的初始化操作，对类中数据结构的任何修改，包括字段的赋值操作（一个典型的例子是setter方法）
* 抛出一个异常
* 进行输入/输出操作，比如向一个文件写数据



### 不可变对象

> 不可变对象是这样一种对象，它们一旦完成初始化就不会被任何方法修改状态。
>
> 意味着一旦一个不可变对象初始化完毕，它用元不会进入到一个无法预期的状态，可以放心地共享它，无需保留任何副本，并且由于它们不会被修改，还是**线程安全**的



### 命令式编程

### 声明式编程

### 引用透明性

### tail-call optimization (尾-调优化)

### 一等函数

> 能够像普通变量一样使用的函数

### high-order function (高阶函数)

高阶函数的基本特征

* 接受至少一个函数作为参数
* 返回的结果是一个函数



### 科里化

> 科里化是一种将具备2个参数（比如，x和y）的函数f转换为使用一个参数的函数g，并且整个函数的返回值也是一个函数，它会作为新韩淑的一个参数。后者返回值和初始函数的返回值相同，即f(x,y)=(g(x)(y))



### 延迟计算、非限制式计算/名调用



### 模式匹配



### 访问者设计模式