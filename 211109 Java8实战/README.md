结构

* 基础知识
* 函数式数据处理
* 高效Java8编程
* 超越Java8



## 第一部分 基础知识（第1章~第3章）

> 初步使用Java8，对Lambda表达式有充分的了解，并可以编写简洁而灵活的代码，能够轻松适应不断变化的需求

1. Java的主要变化
2. 了解行为参数化
3. 全面解释Lambda表达式和方法引用

### 1.为什么关心Java8

* 请记住语言生态系统的思想，以及语言面临的“**要么改变，要么衰亡**”的压力。虽然Java可能现在非常有活力，但你可以回忆一下其他曾经也有活力但未能及时改进的语言的命运，如COBOL
* Java8中新增的核心内容提供了令人激动的新概念和功能，方便我们编写既**有效又简洁**的程序
* 现有的Java编程实践（（指Java8之前））并不能很好地利用多核处理器
* 函数是一等值；记得方法如何作为函数式值来传递，还有Lambda是怎样写的
* Java8中Streams的概念使得Collections的许多方面得以推广，让代码更为易读，并允许并行处理流元素
* 你可以在接口中使用默认方法，在实现类没有实现方法时提供方法内容
* 其他来自函数式编程的有趣思想，包括处理null和使用模式匹配

### 2.通过行为参数化传递代码

* 行为参数化，就是一个方法接受多个不同的新为作为参数，并在内部使用它们，完成不同行为的能力
* 行为参数化可让代码更好地适应不断变化的要求，减轻未来的工作量
* 传递代码，就是将新行为参数传递给方法。但在Java8之前这实现起来很啰嗦。为接口声明许多只用一次的实体类而造成的啰嗦代码，但在Java8之前可以用匿名类来减少
* Java API 包含很多可以用不同行为进行参数化的方法，包括排序、线程和GUI处理

### 3.Lambda表达式

关键概念

* **Lambda表达式** 可以理解为一种匿名函数：它没有名称，但有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常的列表
* Lambda表达式让你可以简洁地传递代码
* **函数式接口**就是仅仅声明了一个抽象方法地接口
* 只有在接受函数式接口的地方才可以使用Lambda表达式
* Lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且**将整个表达式作为函数式接口的一个实例**
* Java8自带一些常用的函数式接口，放在`java.util.function`包里，包括`Predicate<T>`、`Function<T,R>`、`Supplier<T>`、`Consumer<T>`和`BinaryOperator<T>`
* 为了避免装箱操作，对`Predicate<T>`和`Function<T,R>`等通用函数式接口的原始类型特化：`IntPredicate`、`IntToLongFunction`等
* 环绕执行模式（即在方法所必需的代码中间，你需要执行点儿什么操作，比如资源分配和清理)可以配合Lambda提高灵活性和可重用性
* Lambda表达式所需要代表的类型称为**目标类型**
* 方法引用让你重复使用现有的方法实现并直接传递它们
* Comparator、Predicate和Function等函数式接口都有几个可以用来结合Lambda表达式的默认方法

##第二部分 函数式数据处理（第4章~第7章）

> 充分理解流是什么
>
> 如何在Java应用程序中使用它们来简洁而高效地处理数据集

4. 介绍流的概念，并解释它们与集合有何异同
5. 详细讨论了表达复杂数据处理查询可以使用的流操作。如筛选、切片、查找、匹配、映射和归约
6. 收集器——Stream API的一个功能，可以让你表达更为复杂的数据处理查询
7. 了解流如何得以自动并行执行，并利用多核架构的优势、此外，你还会学到为正确而高效地使用并行流，要避免的若干陷阱



### 4.引入流

* 流是“从支持数据处理操作的源生成的一系列元素”
* 流利用内部迭代：迭代通过`filter`、`map`、`sorted`等操作被抽象掉了
* 流操作有两类：中间操作和终端操作
* `filter`和`map`等中间操作会返回一个流，并可以链接在一起。可以用它们来设置一条流水线，但并不会生成任何结果
* `forEach`和`count`等终端操作会返回一个非流的值，并处理流水线以返回结果
* 流中的元素是按需计算的



### 5.使用流

* Streams API可以表达复杂的数据处理查询。常用的流操作
* 你可以使用`filter`、`distinct`、`skip`和`limit`对流筛选和切片
* 你可以使用`map`和`flatMap`提起或转换流中的元素
* 你可以使用`findFirst`和`findAny`方法查找流中的元素。你可以用`allMatch`、`noneMatch`和`anyMatch`方法让流匹配给定的`Predicate`
* 这些方法都利用了短路：找到结果就立即停止计算；没有必要处理整个流
* 你可以利用`reduce`方法将流中所有的元素迭代合并一个结果，例如求和或查找最大元素
* `filter`和`map`等操作是无状态的，它们并不存储任何状态。`reduce`等操作要存储状态才能计算出一个值。`sorted`和`distinct`等操作也要存储状态，因为它们需要把流中的所有元素缓存起来才能返回一个新的流。这种操作称为**有状态操作**
* 流有三种基本的原始类型特化：`IntStream`、`DoubleStream`和`LongStream`。它们的操作也有相应的特化。
* 流不仅可以从集合创建，也可从值、数组、文件以及iterate和generate等特定方法创建
* 无限流是没有固定大小的流



### 6.用流收集数据

* collect是一个终端操作，它接受的参数是将流中元素累积到汇总结果的各种方式（称为收集器）
* 预定义收集器包括将流元素归约和汇总到一个值，例如计算最小值、最大值或平均值。表6-1
* 预定义收集器可以用`groupingBy`对流中元素进行分组，或用`partitioningBy`分区
* 收集器可以高效地复合起来，进行多级分组、分区和归约
* 你可以实现Collector接口中定义的方法来开发你自己的收集器

### 7.并行数据处理与性能

* 内部迭代让你可以并行处理一个流，而无需在代码中显示使用和协调不同的线程
* 虽然并行处理一个流很容易，却不能保证程序在所有情况下都运行得更快。并行软件的行为和性能有时是违反直觉的，因此一定要测量，确保你并没有把程序拖得更慢
* 像并行流那样对一个数据集并行执行操作可以提升性能，特别是要处理的元素数量庞大，或处理单个元素特别耗时的时候
* 从性能角度来看，使用正确的数据结构，如尽可能利用原始流而不是一般化的流，几乎总是比尝试并行化某些操作更为重要
* 分支/合并框架让你得以用递归方式将可以并行的任务拆分成更小的任务，在不同的线程上执行，然后将各个子任务的结果合并起来生成整体结果
* Spliterator定义了并行流如何拆分它要遍历的数据

## 第三部分 高效Java8编程（第8章~第12章）

> 探讨高效使用Java8在代码中运用现代语汇地若干内容

8. 探讨如何利用Java8的新功能和一些秘诀来改善现有的代码
9. 了解默认方法是什么，如何利用它们来以兼容的方式演变API，一些实际的应用模式以及有效使用默认方法的规则
10. 新的`java.util.Optional`类，它能让你设计出更好的API，并减少NPE
11. 探讨 `CompleteableFuture`，可以让你用声明性方式表达复杂的异步计算，从而让Stream API 的设计并行化
12. 探讨新的日期和时间API

### 8.重构、测试和调试

* Lambda表达式能提升代码的可读性和灵活性
* 如果你的代码中使用了匿名类，尽量用Lambda表达式替换它们，但是要注意二者间语义的微妙区别，比如关键字`this`，以及变量隐藏
* 跟Lambda表达式比起来，方法引用的可读性更好
* 尽量使用Stream API 替换迭代式的集合处理
* Lambda表达式有助于避免使用面向对象设计模式时容易出现的僵化的模板代码，典型的比如`策略模式`、`模板方法`、`观察者模式`、`责任链模式`，以及`工厂模式`
* 即使采用了Lambda表达式，也同样可以进行单元测试，但是通常你应该关注使用了Lambda表达式的方法的行为
* 尽量将复杂的Lambda表达式抽象到普通方法中
* Lambda表达式会让栈跟踪的分析变得更为复杂
* 流提供的`peek`方法在分析Stream流水线时，能将中间变量的值输出到日志中，是非常有用的工具

### 9. 默认方法

* Java8中的接口可以通过默认方法和静态方法提供方法的代码实现
* 默认方法的开头以关键字default修饰，方法体与常规的类方法相同
* 向发布的接口添加抽象方法不是原阿门兼容的
* 默认方法的出现能帮助库的设计者以后向兼容的方法演进API
* 默认方法可以用于创建可选方法和行为的多继承
* 我们有办法解决由于一个类从多个接口中继承了拥有相同的函数签名的方法而导致的冲突
* 类或者父类中声明的方法的优先级高于任何默认方法。如果前一条无法解决冲突，那就选择同函数签名的方法中实现得最具体的那个接口的方法
* 两个默认方法都同样具体时，你需要在类中覆盖该方法，显式地选择使用哪个接口中提供的默认方法

### 10.用Optional取代`null 

* `null`引用在历史上被引入到程序设计语言中，目的是为了表示变量值的缺失
* Java 8中引入了一个新的类`java.util.Optional<T>`，对存在或缺失的变量值进行建模
* 你可以使用静态工厂方法`Optional.emppty`、`Optional.of`以及`Optional.ofNullable`创建Optional对象
* Optional类支持多种方法，比如`map`、`flatMap`、`filter`，它们在概念上与Stream类中对应的方法十分相似
* 使用Optional会迫使你更积极地解引用Optional对象，以应对变量值缺失的问题，最终，你能更有效地防止代码中出现不期而至的空指针异常
* 使用Optional能帮助你设计更好的API，用户只需阅读方法签名，就能了解该方法是否接受一个Optional类型的值

### 11.CompletableFuture：组合式异步编程

* 执行比较耗时的操作时，尤其是那些依赖一个或多个远程服务的操作，使用异步任务可以改善程序的性能，加快程序的响应速度
* 你应该尽可能地为客户提供异步API。使用CompletableFuture类提供的特性，你能够轻松地实现这一目标
* CompletableFuture类还提供了异常管理的机制，让你有机会抛出/管理异步任务执行中发生的异常
* 将同步API的调用封装到一个CompletableFuture中，你能够以异步的方式使用其结果
* 如果异步任务之间相互独立，或者它们之间某一些的结果是另外一些的输入，你可以将这些异步任务构造或者合并成一个
* 你可以为CompletableFuture注册一个回调函数，在Future执行完毕或者它们计算的结果可用时，针对性地执行一些程序
* 你可以决定在什么时候结束程序的执行，是等待由CompletableFuture对象构成的列表中所有的对象都执行完毕，还是只有其中任何一个首先完成就中止程序的运行

### 12.新的日期和时间API

* Java 8之前老版的java.util.Date类以及其他用于建模日期时间的类由很多不一致或设计上的缺陷，包括易变性以及糟糕的偏移值、默认值和命名
* 新版的日期和时间API中，日期-时间对象是不可变的
* 新的API提供了两种不同的时间表示方式，有效地区分了运行时人和机器的不同需求
* 你可以用绝对或者相对的方式操作日期和时间，操作的结果总使返回一个新的实例，老的日期时间对象不会发生变化
* TemporalAdjuster让你能够用更精细的方式操纵日期，不再局限与一次只能改变它的一个值，并且你还可按照需求定义自己的日期转换器
* 你先可以按照特定的格式需求，定义自己的格式器，打印输出或者解析日期-时间对象。这些格式器可以通过模板创建，也可以自己编程创建，并且它们都是线程安全的
* 你可以用相对于某个地区/位置的方式，或者以与`UTC/格林尼治时间`的绝对偏差的方式表示时区，并将应用到日期-时间对象上，对其进行本地化
* 你现在可以使用不同于ISO-8601标准系统的其他日历系统

## 第四部分 超越Java8（第13章~第16章）

> 如何用Java8编写高效的函数式程序
>
> 介绍Java中的函数式编程
>
> Java8和Scala中相关的特性进行比较

13. 完整的函数式编程教程，介绍一些术语，并解释了如何在Java8中编写函数式风格的程序
14. 涵盖了更高级的函数时编程技巧，包括高阶函数、科里化、持久化数据结构、延迟列表和模式匹配
15. 对比Java8的Scala的功能
16. 回顾Java8并慢慢走向函数式编程的历程。以及未来的增强和新功能



### 13.函数式的思考

* 从长远看，减少共享的可变数据结构能帮助你降低维护和调试程序的代价
* 函数式编程支持无副作用的方法和声明式编程
* 函数式方法可以由它的输入参数及输出结果进行判断
* 如果一个函数使用相同的参数值调用，总使返回相同的结果，那么它是引用透明的。采用递归可以取得迭代式的结构，比如while循环
* 相对于Java语言中传统的递归，“尾-递”可能是一种更好的方式，它开启了一扇门，让我们有机会最终使用编译器进行优化

### 14.函数式编程的技巧

* 一等函数式可以作为参数传递，可以作为结果返回，同时还能存储在数据结构中的函数
* 高阶函数接受至少一个或者多个函数作为输入参数，或者返回另一个函数的函数。Java中典型的高阶函数包括comparing、andThen和compose
* 科里化是一种帮助你模块化函数和重用代码的技术
* 持久化数据结构在其被修改之前会对自身前一个版本的内容进行备份。因此，使用该技术能避免不必要的防御式复制
* Java语言中的Stream不是自定义的
* 延迟列表式Java语言中让Streanm更具表现力的一个特性。延迟列表让你可以通过辅助方法（supplier）即时地创建列表中的元素，辅助方法能帮忙创建更多的数据结构
* 模式匹配是一种函数式的特性，它能帮助你解包数据类型。它可以看成Java语言中switch语句的一种泛化
* 遵守“引用透明性”原则的函数，其计算结构可以进行缓存
* 结合器是一种函数式的思想，它指的是将两个或多个函数或者数据结构进行合并