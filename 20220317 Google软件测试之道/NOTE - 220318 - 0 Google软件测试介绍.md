# Google 软件测试介绍

> 与功能相比，Google工程师更看重质量（产品的稳定性和可靠性）
>
> Google成功的关键之一：不要招聘太多的测试人员

1.1 质量不等于测试

0 质量不是被测试出来的

当你把开发过程和测试放到一起，就像在搅拌机里混合搅拌那样，直到不能区分彼此的时候，你就得到了质量。

> 在Google，这正是我们的目标，就是把开发过程和测试融合在一起————开发和测试必须同时开展。



1 由谁来做这些测试呢？

开发对质量的负责——Google能用如此少的专职测试人员的原因

* 还有谁能比实际写代码的人更适合做测试呢？
* 还有谁能比实际写代码的人更适合去寻找bug呢？
* 是谁会为了避免受更大刺激而去想办法避免产生bug呢？
* [提醒开发人员的最佳测试实践](http：//googletesting.blogspot.com/2007/01/introducing-testing-on-toilet.html)

> 测试是开发过程中必不可少的一部分，当开发过程和测试一起携手联姻时，即是质量达成之时



1.2 角色

0 软件开发工程师（SWE——software engineer）

职责

传统上的开发角色，他们的工作是实现最终用户所使用的功能代码

工作内容

* 创建设计文档、选择最优的数据结构和整体架构
* 花费大量实践在代码实现与代码审核上
* 编写测试代码，包括测试驱动的设计、单元测试、参与构建各种大小规模的测试等
* 增加功能性或提高性能的代码
* 对他们编写、修复以及修改的代码承担质量责任
* 花费大量时间在代码上　－　为客户使用功能的开发实现



1 软件测试开发工程师（SET——software engineer in test）

职责

开发角色，工作重心在可测试性和通用测试基础框架上

工作内容

* 参与设计评审，近距离观察代码质量与风险
* 对代码进行重构，并编写单元测试框架和自动化测试框架，以增加可测试性
* 更加关注于代码质量提升和测试覆盖率的增加
* 花费大量时间在代码上 ——　为质量服务
* 让开发者可以很容易地编写测试代码

> SET 是 SWE 在代码库上的合作伙伴，与增加功能性代码或提高性能的代码的 SWE 相比，SET 更加关注于质量的提升和测试覆盖率的增加。
>
> SET 写代码的目的是可以让 SWE 测试自己的功能



2 测试工程师（TE——test engineer）

职责

是一个和 SET 关系密切的角色，关注 把用户放在第一位来思考，代表用户的利益

工作内容

* 花费大量时间在模拟用户的使用场景和自动化脚本或代码的编写上
* 将 SWE 和 SET 编写的测试分门别类地组织起来，分析、解释、测试运行结果，驱动测试执行
* 构建端到端的自动化测试
* 项目后期阶段，推进产品发布
* TE 是真正的产品专家、质量顾问和风险分析师
* 可能编写大量代码，可能编写少量代码



> 从质量角度来看
>
> SWE 负责功能实现和这些独立功能的质量，对容错设计、故障恢复、测试驱动设计、单元测试负责，并和 SET 一起编写测试代码
>
> SET 负责提供测试支持，通过编写测试框架或代码其提供的功能让 SWE 能够自己测试他们的功能
>
> TE 具备双重确认的功能，确认SWE 早期的测试工作以及用户使用场景的测试工作



1.3 组织结构

工程生产力团队

> 测试是独立存在的部门，是与专注领域部门平行的部门（横跨各个产品专注领域），我们称为工程生产力团队
>
> 对于一个测试人员，如果在某个产品中工作满18个月之后，就可以无理由地自愿转岗到其他产品，当然这个转岗不是强制的

* 有自己选择决定的优先级，在可靠性、安全性等问题上不会妥协
* 可以保持数量较少的测试人员，产品团队不能任意降低测试人员招聘的技术要求
* 工程生产力团队会根据不同产品团队的优先级、复杂度，并与其他产品实际比较之后，再来分配测试人员

对测试人员的影响

* 让 SET 和 TE 保持新鲜感并且总是很忙碌
* 让测试人员具备对各个产品与技术都了解的能力，这种人员对公司是有利的
* 一个好的测试想法可以在公司内部快速蔓延
* 让测试人员接触到不同的语言和平台
* 让测试人员很容易地保持相关的专业技能，并在公司范围内的产品之间自由穿梭



1.4 Google的版本发布

> Gmail戴上beta版本的标签，运营了四年
>
> 
>
> 在一个产品的基本核心功能实现之后，就立刻对外发布使用，然后从用户那里得到真实反馈，再进行迭代开发
>
> 
>
> Google经常在最初的版本里只包含最基本的可用功能
>
> 然后在后继的快速迭代的过程中得到内部和外部用户的反馈，而且在每次迭代的过程中都非常注重质量
>
> 一个产品在发布给用户使用之前，一般都要经历金丝雀版本、开发版本、测试版本、beta版本或正式发布版本

不同的版本

* 金丝雀版本
  * 每日构建版本
  * 排除过滤一些明显不适宜的版本，对一件事情的预警版本
  * 产品工程师（开发或测试人员）和管理人员会安装使用
* 开发版本
  * 开发人员日常使用的版本
  * 一般每周发布一次
  * 具有一定的功能并通过了一系列的测试
  * 产品下的所有工程师都被要求安装，并真正使用
* 测试版本
  * 通过了持续测试的版本
  * 基本上是一个月里的最佳版本
  * 工程师日常工作中使用的最稳定最信任的一个版本
  * 可被挑选为内部尝鲜（dog food）版本或beta测试的候选版本
* beta或发布版本
  * 由非常稳定的测试版本演变而来
  * 经历了内部使用和通过所有质量考核的一个版本
  * 对外发布的第一个版本



1.5 测试类型

> Google 并没有使用代码测试、集成测试、系统测试这些命名方式
>
> 而是使用小型测试、中型测试、大型测试这样的称谓
>
> 着重强调测试的范畴规模而非形式

* 小型测试

  验证一个单独函数或独立功能模块的代码是否按照预期工作，着重于典型功能性问题、数据损坏、错误条件和off-by-one错误

  主要尝试解决“代码是否按照预期的方式运行”

  * 运行时间短
  * 可自动化实现
  * 由SWE来实现，会有少量的SET参与
  * TE几乎不参与，会参与运行这些测试，来诊断一些特定错误

* 中型测试

  测试重点在于验证“功能近邻区（功能交互区域）”之间的交互，以及彼此调用时的功能是否正确

  主要尝试解决“一系列临近的模块互相交互的时候，是否如我们预期的那样工作”

  * 可自动化实现
  * 一般涉及多个模块的交互
  * SET 会驱动这些测试的实现及运行
  * SWE 会深度参与编码、调试和维护这些测试

* 大型测试

  关注所有模块的继承，更倾向于结果驱动，验证软件是否满足最终用户的需求

  主要尝试解决“这个产品操作运行方式是否和用户的期望相同，并产生的结果”

  关注重点是端到端的使用场景以及在整体产品或服务之上的操作行为

  * 通常涵盖三个或以上的功能模块
  * 所有的工程师角色都会参与到大型测试之中
  * 使用真实用户场景和实际用户数据
  * 一般耗时数小时或更长时间

[whats-the-difference-between-faking-mocking-and-stubbing?](http：//stackoverflow.com/questions/346372/whats-the-difference-between-faking-mocking-and-stubbing)

> 如果能够自动化，并不需要人脑的智睿与直觉来判断，那就应该以自动化的方式实现
>
> 将自动化做到，力争“克服人类智慧的最后一英里”，也是Google的设计理念与目标，也正是正在构建之中下一代测试工具的努力方向