# Before The Project

## 需求之坑

> 完美，不是在没有什么需要增加，而是在没有什么需要去掉时达到的。
>
> ​					———— Antoine de St.Exupery, Wind,Stand,and Stars,1939



### 识别出真实的需求？

需求是对需要完成的某件事情的陈

#### 如何搜集需求？

* 不要搜集需求，去挖掘需求
* 成为用户

#### 挖掘需求

需求常常会嵌入商业政策。政策经常会改变，对此可以以以下这种方式处理

* 将这些政策的文档与需求的文档分开，并用超链接把两者连接起来
* 使需求成为一般陈述，并把政策信息作为例子发给开发者 —— 他们需要在实现中支持的事物类型的例子
* 最后，政策可以成为应用中的元数据

当政策改变时，只有该系统的元数据需要更新。**事实上，以这样的方式搜集需求会很自然地让你去开发为支持元数据而进行了良好分解的系统**。

> 找出用户为何要做特定事情的原因、而不只是他们目前做这件事情的方式，这很重要

### 建立需求文档

> 成功的工具会适应使用他们的双手

通过用例捕捉需求

![](C:\Users\Administrator\Desktop\211129 程序员修炼之道：从小工到专家\images\用例模板.png)



好的需求文档会保持抽象

> 需求不是架构。需求不是设计，也不是用户界面。需求是需要



积极地追踪需求的各项指标

* 谁请求增加新特性
* 谁批准的，批准的请求总数是多少
* etc

> 管理需求增长的关键是向项目出资人指出每项新特性对项目进度的影响。
>
> 当项目已经拖后了一年，各种责难开始纷飞时，能够准确、完整地了解需求增长是怎样及何时发生的，会很有帮助



### 维护词汇表

> 要创建并维护项目词汇表(project glossary) 这是定义项目中使用的专用术语和词汇的地方
>
> 项目的所有参与者,从最终用户到支持人员,都应该使用这个词汇表,以确保一致性
>
> 这就意味着,可以访问词汇表的人员范围应该很广泛 (这是采用基于WEB的文档的一个有效论据)



#### 基于WEB的分发方式

> 通过把需求文档制作成超文本文档,我们可以更好地满足不同听众地需求,我们可以给每个读者他们想要的东西
>
> 基于WEB的分发方式还能让你避免典型的两英寸厚的文件夹 名为需求分析,其实永远没有人阅读,墨水刚沾上纸面,就过时了
>
> 如果它在Web上,连程序员都可以阅读它



## 解开不可能解开的谜题

戈尔迪斯结的故事

### 自由度

流行的俗话“在盒子外面思考”鼓励我们找出不适用的约束，并忽略它们、但这个俗语并不完全准确。如果“盒子”是各种约束和条件的边界，那么诀窍就在于找到盒子，它可能比你以为的要大得多。

解开谜题的关键在于确定加给你各种约束，并确定你确实拥有的自由度，因为在其中你将找到你的解决方案。

> 问题并不在于你是在盒子里面思考，还是在盒子外面思考，而在于找到盒子，从而确定真正的约束

如果特定的问题是“不可能解决的”，尝试问自己以下问题

* 有更容易的方法吗？
* 你是在设法解决真正的问题，还是被外围的技术问题转移了注意力？
* 这件事情为什么是一个问题？
* 它必须以这种方式完成吗？
* 它真的必须完成吗？

> 很多时候，当你设法回答这些问题时，你会有让自己吃惊的发现。很多时候，对需求的重新诠释能让整个问题全都消失——就像是戈尔迪斯结



## 等你准备好

> 有时犹豫的人会得以保全————James Thurber，The Glass in the Field



## 规范陷阱

编写规范是一项重要职责，但是认为规范的每一处小细节都极端详细地确定下来是错误的，原因如下：

* 认为规范将捕捉系统或其需求的每一处细节和细微差别，这很幼稚。
* 语言自身的表达能力存在这问题



> 作为注重实效的程序员，你应该倾向于把需求搜集、设计、以及实现视为同一个过程————交付高质量的系统的不同方面
>
> 不要信任这样的环境：搜集需求、编写规范、然后开始编码，所有这些步骤都是孤立进行的。
>
> 相反，要设法采用无缝的方法：规范和实现不过是同一个过程————设法捕捉和编纂需求的不同方面

## 圆圈与箭头

> 注重实效的程序员批判地看待方法学，并从各种方法学中提取精华，融合成每个月都在变得更好的一套工作习惯。
>
> 这至关紧要。
>
> 你应该不断努力提炼和改善你的开发过程。决不要把方法学的呆板限制当作你的世界的边界。





## 