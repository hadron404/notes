# While You Are Coding

## 靠巧合编程

> 不主动思考他们的代码的开发者是在靠巧合编程 代码也许能工作,但却没有特别的理由说明它们为何能工作.
>
> 我们应该避免靠巧合编程—— 依靠运气和偶然的成功 —— 而要**深思熟虑地编程**



什么是靠巧合的编程?

* 实现的偶然
* 语境的偶然
* 隐含的假定


如何深思熟虑地编程?

* 总是意识到你在做什么
* 不要盲目地编程.试图构建你不完全理解的应用,或是使用你不熟悉的技术,就是希望自己被巧合误导
* 按照计划行事
* 依靠可靠的事物 不要依靠巧合或假定
* 为你的假定建立文档
* 不要只是测试你的代码,还要测试你的假定
* 为你的工作划分优先级
* 不要做历史的奴隶



## 算法速率

## 



![](C:\Users\Administrator\Desktop\211129 程序员修炼之道：从小工到专家\images\一些常见的O()表示法.png)



使用一些常识估算许多基本算法的阶

1. 简单循环. ---- O(n)
2. 嵌套循环. ---- O(m * n)
3. 二分法. ------ O(lg(n))
4. 分而治之. ---- O(nln(n))
5. 组合



提高设计与分析算法才能的书籍

* Robert Sedgewick [Sed83，SF96，Sed92] --- 易于理解
* Donald Knuth 的权威著作 Art of Computer Programming -- 更加深入,分析了广泛的算法

## 重构

> 周遭所见,皆是变易与衰败.....
>
> ---- H.F.Lyte <请与我同在>

代码出现以下特征，请考虑重构

1. 重复,你发现了对DRY原则的违反
2. 非正交的设计,你发现有些代码或设计可以变得更为正交
3. 过时的知识
4. 性能



如何进行利大于弊的重构

1. 不要视图在重构的同时增加功能
2. 在开始重构之前,确保你拥有良好的测试.尽可能经常运行这些测试.这样,如果你的改动破坏了任何东西,你就能很快知道.

## 易于测试的代码

软件IC 是人们在讨论可复用性和基于组件的开发时喜欢使用比喻.意思是软件组件应该就像集成电路芯片一样进行组合



### 单元测试

> 在隔离的状态下对每个模块进行测试,目的是检验其行为.
>
> 软件的单元测试是对模块进行演练的代码



### 针对合约进行测试

> 我们喜欢把单元测试视为针对合约的测试.
>
> 我们想要编写测试用例,确保给定的单元遵守其合约
>
> 这将告诉我们两件事情:
>
> 代码是否符合合约,以及合约的含义是否与我们所认为的一样.
>
> 我们想要通过广泛的测试用例与边界条件,测试模块是否实现了它允诺的功能.



### 编写单元测试

编写的单元测试应放置在方便的地方.



编写单元测试的好处:

1. 一些例子,说明怎样使用你的模块的所有功能
2. 用以构建回归测试,以验证未来对代码的任何改动是否正确的一种手段



### 使用测试装备(testing harness)

测试装备的作用 -- 可以处理一些常用操作

* 记录状态
* 分析输出是否符合预期的结果
* 选择和运行测试

测试装备都应该具有以下功能

1. 用以指定设置与清理(setup and cleanup)的标准途径
2. 用以选择个别或所有可用测试的方法
3.  分析输出是否是预期(或意外)结果的手段
4. 标准化的故障报告形式
5. 测试应该是可组合的,可以由子组件的子测试组合到任意深度



### 测试文化

> 你编写的所有软件都将进行测试-- 如果不是由你和你们团队测试,那就要由最终用户测试 -- 所有你最好计划好对其进行彻底的测试.
>
> 一点预先的准备可以大大降低维护费用,减少客户服务电话.



顺应性

​	测试被放在特定的地方,并且有着预期的输出.测试是技术,但更是文化;不管所用语言是什么,我们都可以让这样的测试文化慢慢渗入项目中.



## 邪恶的向导

### Don't Use Wizard Code You Don't Understand

我们不是在反对向导.相反,我们用了整整一节(代码生成器)专门讨论怎样编写你自己的向导.但如果你真的使用向导,却不理解它制作出的所有代码,你就无法控制你自己的应用.你没有能力维护它,而且在调试时会遇到很大的困难.