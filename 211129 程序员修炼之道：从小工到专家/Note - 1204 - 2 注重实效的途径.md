# Chapter2 注重实效的途径 A Pragmatic Approach

## 7 重复的危害

> 给予计算机两项自相矛盾的知识，是James T.Kirk舰长喜欢用来使四处劫掠的人工智能生命失效的方法。

​	可靠地开发软件，并让我们的开发更易于理解和维护的唯一途径，使遵循我们称之为DRY的原则：**系统中的每一项知识都必须具有单一、无歧义、权威的表示**。

### 重复的类别（4I重复）

1. **`I`mposed Duplication**: 开发者觉得他们无可选择——环境似乎要求重复
2. **`I`nadvertent Duplication:** 开发者没有意识到他们在重复信息
3. **`I`mpatient Duplication:** 开发者偷懒，他们重复，因为那样似乎更容易
4. **`I`nterdeveloper Duplication:** 同一团队（或不同团队）的几个人重复了同样的信息

#### 如何避免`Imposed Duplication`以遵守DRY原则？

* 信息的多种表示
  * 编写简单的过滤器或代码生成器 以消除 不同的形式表示同一信息这样类似的需求 
* 代码中的文档
  * 糟糕的代码才需要很多注释：要把低级的知识放在代码中（它属于那里），把注释保留给其他的高级说明（避免既要改变代码，也要改变注释）
* 文档与代码
  * （C、C++ ）头文件（重复了被导出变量、函数和的类的名称和类型信息）
  * 没有理由在头文件和试下那文件中重复函数或类头注释（header comment）：用头文件记载接口，用实现文件记载代码的使用者无须了解的实际细节

#### `Inadvertent Duplication`

> 有时，重复来自设计中的错误。<u>ps:需要原文</u>

在以后的开发过程中。你可以因为性能原因而选择违反DRY原则（这经常会发生在你需要缓存数据，以避免重复昂贵的操作时）。其诀窍是**使影响局部化**。对DRY原则的违反没有暴露给外界：只有类中的方法需要注意“保持行为良好”。



#### `Impatient Duplication`

> 每个项目都有时间压力——这是能够驱使我们中间最优秀的人走捷径的力量。
>
> 
>
> 如果你觉得受到诱惑，想一想古老的格言：“欲速则不达”。<u>ps：需原文</u>

impatient duplication 是一种容易检测和处理的重复形式，但那需要你接受训练，并愿意为避免以后的痛苦而预先花一些时间。



#### `Interdevloper Duplication`

> interdevloper duplication 也许是最难检测和处理的重复发生在项目的不同开发者之间。

在高层，可以通过清晰的设计、强用力的技术项目领导，以及在设计中进行得到了充分理解的责任划分，对这个问题加以处理。



我们觉得，处理这个问题的最佳方式是**鼓励开发者相互进行主动的交流**

* 可以设置论坛：讨论常见的问题
* 让某个团队成员担任项目资料管理员：以促进知识的交流
* 源码树中指定一个中央区域：用于存放实用例程和脚本

<u>ps: 需原文</u>



## 8 正交性

###### 几何学中的正交性

​	如果两条值线相交成直角，它们就是正交的。用向量的术语说，这两条直线互不依赖。沿着某一条直线移动，你投影到另一条直线上的位置不变。

###### 计算技术中的正交性

​	在计算技术中，该术语用于表示**某种不相依赖性或是解耦性**。如果两个或多个事物中的一个发生变化，不会影响其他事务，这些事物就是正交的。

###### 非正交系统

​	比如直升的各个控制器断然不是正交的。

### 正交的好处

* 提高生产率：改动得以局部化
* 降低风险：正交的途径能降低任何开发中固有的风险
  * 有问题的代码区域被隔离开来
  * 所得系统更健壮

非正交系统的改变与控制更复杂是其固有的性质。当任何系统的各组件互相高度依赖时，就不再有局部修正（local fix）这样的事情。



#### 工作中应用正交原则的几种方式

* 项目团队
* 设计
  * 不要依赖你无法控制地事物属性
* 工具箱与库
* 编码
  * 让你的代码保持解耦性
  * 避免使用全局数据
  * 避免编写相似的函数
* 测试
  * 构建模块级（单元）测试
* 文档
* 认同正交性

##### 怎样把团队划分为责任得到了良好定义的小组，并使重叠降至最低呢？

> 我们的偏好是从使基础设施与应用分离开始。
>
> 每个主要的基础设施组件（数据库、通信接口、中间层等等）有自己的子团队。
>
> 如果应用功能的划分显而易见，那就照此画风。
>
> 然后我们考察我们现有的（或计划有的）人员，并对分组进行相应的调整。

你可以对项目团队的正交性进行非正式的衡量。
只要看一看，在讨论的每个所需改动时需要设计多少人。人数越多，团队的正交性就越差。



#####  对于正交设计，有一种简单的测试方法，一旦设计好组件，问问你自己?

1. 如果我显著地改变某个特定功能背后地需求，有多少模块会受影响？在正交系统中，答案应该是一个


##### 第三方库或工具中正交性的例子

1. Enterprise Java Beans(EJB)
2. Aspect-Oriented Programming(AOP)

##### 编码使用若干技术维持正交性

1. 让你的代码保持解耦（Law of Demeter）
2. 避免使用全局数据
3. 避免编写相似的函数
   1. 养成不断地批判对待自己的代码的习惯
   2. 寻找任何重新进行组织、以改善其结构和正交性的机会

##### 如何测试评估系统的正交性？

> 正交的设计和实现的系统也更易于测试，因为系统的各组件间的交互是形式化的和优先的，更多的系统测试可以在单个模块级进行。

1. 构建单元测试：建议让每个模块都拥有自己的、内建在代码中的单元测试，并让这些测试作为常规构建过程的一部分自动运行
2. 修正bug：遇到问题时，评估修正的局部化



##### 认同正交性

> 运用DRY原则，你是在寻求使系统中的重复降至最小；
>
> 运用正交性原则，你可减低系统的各组件间的相互依赖。

如果你紧密结合DRY原则、运用正交性原则，你将会发现你开发的系统会变得更为灵活、更易于理解并且更易于调试、测试和维护





## 9 可撤销性

> 如果某个想法是你唯一的想法，再没有什么比这更危险的事情了。——Emil-Auguste Chartier,Propos sur la religion,1938

没有什么永远不变——而如果你严重依赖某一事实，你几乎可以确定它将会变化。



错误在于假定决策是浇铸再石头上的———— 同时还在于为可能出现的意外事件做准备。要把决策视为是写在沙滩上的，而不要把它们刻在石头上。大浪随时可能到来，把它们抹去



## 10 曳光弹

黑暗中用机枪射击 by 曳光弹

​	曳光弹与常规弹药交错着装在弹药带上。发射时，曳光弹中的磷点燃，在枪与它们击中的地方之间留下一条烟火般的踪迹。弱国曳光弹击中目标，那么常规子弹也会击中目标

### 在黑暗中发光的代码

> 曳光弹行之有效，是因为它们与真正的子弹在相同环境、相同的约束下工作。
>
> 它们快速飞向目标，所以枪手可以得到即时的反馈。同时，从实践的角度看，这样的解决方案也更便宜
>
> 为了在代码中获得同样的效果，我们要找到某种东西，让我们能快速、直观和可重复地从需求触发，满足最终系统的某个方面要求



### 用曳光弹找到目标

曳光开发与项目永不会结束的理念是有一致的：总有改动需要完成，总有功能需要增加。这是一个渐进的过程

传统做法（非曳光弹做法）

1. 把代码划分为模块在真空中对模块进行编码
2. 把模块组合成子配件（subassembly）在对子配件进行组合，直到有一天拥有完整的应用为止。
3. 此时，才能把应用作为一个整体呈现给用户，并进行测试



### 曳光代码方法的优点

* 用户能够及早看到能工作的东西
* 开发这构建了一个他们能在其中工作的结构
* 有一个集成平台
* 有了可用于演示的东西
* 更能感觉到工作进展



### 曳光弹并非总能击中目标

> 曳光弹告诉你击中的是什么。那不一定总是目标。



### 曳光代码 VS 原型制作

> 原型制作生成用过就扔的代码。
>
> 曳光代码虽然简约，但却是完整的，并且构成了最终系统的骨架的一部分。
>
> 你可以把原型制作视为在第一发曳光弹发射之前进行的侦察和情报搜集工作



## 11 原型与便签

​	**原型制作是一种学习经验。其加制不在于所产生的代码，而在于所学到的经验教训**。那才是原型制作的要点所在

### 应制作原型的事物

> 任何带有风险的事物。
>
> 以前没有试过的事物，或是对于最终系统极端关键的事物。
>
> 任何未被证明的、实验性的、或有疑问的事物。
>
> 任何让你觉得不舒服的事物

* 架构
* 已有系统中的新功能
* 外部数据的结构或内容
* 第三方工具或组件
* 性能问题
* 用户界面设计



### 怎样使用原型？

#### 在构建原型时，你可以忽略哪些细节？

* 正确性
* 完整性
* 健壮性
* 风格

#### 架构原型中寻求解答的具体问题？

> 事实上，要制作架构原型，你甚至不一定需要进行编码————你可以用便笺或索引卡片、在白板上制作原型

* 主要组件的责任是否得到了良好定义？是否适当？
* 主要组件间的协作是否得到了良好定义？
* 耦合是否得以最小化？
* 你能否确定重复的潜在来源？
* 接口定义和各项约束是否可接受?
* 每个模块在执行过程中是否能访问到其所需的数据？是否能在需要时进行访问?

#### 怎样“不”使用原型

> 别人很容易被演示原型外表的完整性误导，而如果你没有设定正确的期望值，项目出资人或管理部门可能会坚持要部署原型（或其后裔）。
>
> **提醒他们，你可以用轻木和胶带制造一辆了不起的新车原型，但你却不会在高峰时间的车流中驾驶它**
>
> 适当地使用原型，可以帮助你在开发周期地早期确定和改正潜在的问题点————在此时改正错误既便宜、又容易————从而为你节省大量时间、金钱，并大大减轻你遭受的痛苦和折磨



## 12 领域语言

> 语言的界限就是一个人的世界的界限——维特根斯坦
>
> 
>
> 计算机语言会影响你思考问题的方式，以及你看待交流的方式。



Program Close to the problem domain 

​	无论是用于配置和控制应用程序的简单语言，还是用于指定规则或过程的更为复杂的语言，我们认为，你都应该考虑让你的项目更靠近问题领域。通过在更高的抽象层面上编码，你获得了专心解决领域问题的自由，并且可以忽略琐碎的实现细节。



## 13 估算

> 通过学习估算，并将此技能发展到你对事物的数量级有直觉的程度，你就能展现出一种魔法般的能力，确定它们的可行性。



### 1 估算的精确度：多准确才足够准确

要选择能反映你想要传达的精确度的单位

#### 度量时间估算的建议

| 时长   | 报出估算的单位           |
| ------ | ------------------------ |
| 1~15天 | 天                       |
| 3~8周  | 周                       |
| 8~30周 | 月                       |
| 30+周  | 在给出估算前努力思考一下 |



### 0 基本的估算诀窍：估算来自哪里

> 所有的估算都以问题的模型为基础。

一个基本的估算诀窍： **去问已经做过这件事情的人**

### 2 把握问题域的范围：理解提问内容

任何估算练习的第一步都是建立对提问内容的理解。

> 问题域的范围，常常隐含在问题中，但你需要养成在开始猜想之前先思考范围的习惯。

### 3 建立系统的模型

> 这是估算有趣的部分。根据你对所提问题的理解，建立粗略、就绪的思维模型股价。



### 追踪你的估算能力

> 我们认为，记录你的估算，从而让你看到自己接近正确答案的程度，这是一个非常好的主意。
>
> 你常常会发现自己估算得非常好————事实上，一段时间之后，你就会开始期待这样的事情。
>
> 如果结果证明估算错了，不管原因是什么花一点时间揭开发生的事情。如果你这样做了，你的下一次估算就会更好

 

### 估算项目进度

> 为项目确定进度表的唯一途径常常是 **在相同的项目上获取经验**

实行增量开发、重复下面的步骤

* 检查需求
* 分析风险
* 设计、实现、集成
* 向用户确认

### Iterate the Schedule with the Code 

> 这种方式可能不会受到管理部门的欢迎。
>
> 你必须帮助他们了解团队、团队的生产率、还有环境决定进度。
>
> 通过使其形式化，并把改进进度表作为每次迭代的一部分，你将给予他们你所能给予的最精确的进度估算。



### 在被要求进行估算时说什么

"我等会回答你。"

​	如果你放慢估算的速度，并花一点时间仔细检查上一节描述的步骤，你几乎总能得到更好的结果。